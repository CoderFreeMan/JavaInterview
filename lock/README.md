# Lock 篇
其实本来 Lock 应该放到 data-structure 模块的，但是为了体现其重要性，
单独用一个篇章来整理。

# 锁的分类介绍

## 乐观锁与悲观锁
锁的一种宏观分类是**乐观锁**与**悲观锁**。乐观锁与悲观锁并不是特定的指哪个锁（Java 中也没有那个具体锁的实现名就叫
乐观锁或悲观锁），而是在并发情况下两种不同的策略。

乐观锁（Optimistic Lock）就是很乐观，每次去拿数据的时候都认为别人不会修改。所以不会上锁。但是如果想要更新数据，
则会在**更新之前检查在读取至更新这段时间别人有没有修改过这个数据**。如果修改过，则重新读取，再次尝试更新，循环上述
步骤直到更新成功（当然也允许更新失败的线程放弃更新操作）。

悲观锁（Pessimistic Lock）就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次都在拿数据的时候上锁。
这样别人拿数据的时候就会被挡住，直到悲观锁释放，想获取数据的线程再去获取锁，然后再获取数据。

**悲观锁阻塞事务，乐观锁回滚重试**，它们个有优缺点，没有好坏之分，只有适应场景的不同区别。比如：乐观锁适合用于写
比较少的情况下，即冲突真的很少发生的场景，这样可以省去锁的开销，加大了系统的整个吞吐量。但是如果经常产生冲突，上层
应用会不断的进行重试，这样反而降低了性能，所以这种场景悲观锁比较合适。
总结：**乐观锁适合写比较少，冲突很少发生的场景；而写多，冲突多的场景适合使用悲观锁**。

## 乐观锁的基础 --- CAS

## 自旋锁

## synchronized 与 Lock interface
Java 中两种实现加锁的方式：一种是使用 synchronized 关键字，另一种是使用 Lock 接口的实现类。

在一篇文章中看到一个好的对比，非常形象，synchronized 关键字就像是**自动挡**，可以满足一切的驾驶需求。
但是如果你想要做更高级的操作，比如玩漂移或者各种高级的骚操作，那么就需要**手动挡**，也就是 Lock 接口的实现类。

而 synchronized 在经过 Java 每个版本的各种优化后，效率也变得很高了。只是使用起来没有 Lock 接口的实现类那么方便。

### synchronized 锁升级过程就是其优化的核心：**偏向锁** -> **轻量级锁** -> **重量级锁**

```java

class Test{
    private static final Object object = new Object(); 
    
    public void test(){
        synchronized(object) {
            // do something        
        }   
    }
    
}

```

使用 synchronized 关键字锁住某个代码块的时候，一开始锁对象（就是上述代码中的 object）并不是**重量级锁**，而是偏向锁。
偏向锁的字面意思就是"偏向于第一个获取它的线程"的锁。线程执行完同步代码块之后，并**不会主动释放偏向锁**。当第二次到达同步
代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程 ID 在对象头里存储），如果是则正常往下执行。**由于之前没有释放，
这里就不需要重新加锁**，如果从头到尾都是一个线程在使用锁，很明显偏向锁几乎没有额外开销，性能极高。

一旦有第二个线程加入**锁竞争**，偏向锁转换为**轻量级锁**（**自旋锁**）。锁竞争：如果多个线程轮流获取一个锁，但是每次获取的时候
都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程获取锁的时候，发现锁已经被占用，需要等待其释放，则说明发生了锁竞争。

## 可重入锁

## 公平锁和非公平锁




 