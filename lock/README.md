# Lock 篇
其实本来 Lock 应该放到 data-structure 模块的，但是为了体现其重要性，
单独用一个篇章来整理。

# 锁的分类介绍

## 乐观锁与悲观锁
锁的一种宏观分类是**乐观锁**与**悲观锁**。乐观锁与悲观锁并不是特定的指哪个锁（Java 中也没有那个具体锁的实现名就叫
乐观锁或悲观锁），而是在并发情况下两种不同的策略。

乐观锁（Optimistic Lock）就是很乐观，每次去拿数据的时候都认为别人不会修改。所以不会上锁。但是如果想要更新数据，
则会在**更新之前检查在读取至更新这段时间别人有没有修改过这个数据**。如果修改过，则重新读取，再次尝试更新，循环上述
步骤直到更新成功（当然也允许更新失败的线程放弃更新操作）。

悲观锁（Pessimistic Lock）就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次都在拿数据的时候上锁。
这样别人拿数据的时候就会被挡住，直到悲观锁释放，想获取数据的线程再去获取锁，然后再获取数据。

**悲观锁阻塞事务，乐观锁回滚重试**，它们个有优缺点，没有好坏之分，只有适应场景的不同区别。比如：乐观锁适合用于写
比较少的情况下，即冲突真的很少发生的场景，这样可以省去锁的开销，加大了系统的整个吞吐量。但是如果经常产生冲突，上层
应用会不断的进行重试，这样反而降低了性能，所以这种场景悲观锁比较合适。
总结：**乐观锁适合写比较少，冲突很少发生的场景；而写多，冲突多的场景适合使用悲观锁**。

## 乐观锁的基础 --- CAS
在乐观锁的实现中，我们必须要了解的一个概念：CAS。

什么是 CAS 呢？ Compare-and-Swap，即**比较并替换**，或者**比较并设置**。

- 比较：读取到一个值 A，在将其更新为 B 之前，检查原值是否为 A（未被其它线程修改过，**这里忽略 ABA 问题**）。

- 替换：如果是，更新 A 为 B，结束。如果不是，则不会更新。

上面两个步骤都是原子操作，可以理解为瞬间完成，在 CPU 看来就是一步操作。

有了 CAS，就可以实现一个乐观锁：

```java

public class OptimisticLockSample{
    
    public void test(){
        int data = 123; // 共享数据
        
        // 更新数据的线程会进行如下操作
        for (;;) {
            int oldData = data;
            int newData = doSomething(oldData);
            
            // 下面是模拟 CAS 更新操作，尝试更新 data 的值
            if (data == oldData) { // compare
                data = newData; // swap
                break; // finish
            } else {
                // 什么都不敢，循环重试
            }
        }   
    }
    
    /**
    * 
    * 很明显，test() 里面的代码根本不是原子性的，只是展示了下 CAS 的流程。
    * 因为真正的 CAS 利用了 CPU 指令。
    *  
    * */ 
    

}

```

在 Java 中也是通过 native 方法实现的 CAS。

```java

public final class Unsafe {
    
    ...
    
    public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);
    
    public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
    
    public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);  
    
    ...
} 


```

上面写了一个简单直观的乐观锁（确切的来说应该是乐观锁流程）的实现，它允许多个线程同时读取（因为根本没有加锁操作），如果更新数据的话，
有且仅有一个线程可以成功更新数据，并导致其它线程需要回滚重试。CAS 利用 CPU 指令，从硬件层面保证了原子性，以达到类似于锁的效果。

从乐观锁的整个流程中可以看出，并没有**加锁**和**解锁**的操作，因此乐观锁策略也被称作为**无锁编程**。换句话说，乐观锁其实不是"锁"，
它仅仅是一个循环重试的 CAS 算法而已。


## 自旋锁

## synchronized 与 Lock interface
Java 中两种实现加锁的方式：一种是使用 synchronized 关键字，另一种是使用 Lock 接口的实现类。

在一篇文章中看到一个好的对比，非常形象，synchronized 关键字就像是**自动挡**，可以满足一切的驾驶需求。
但是如果你想要做更高级的操作，比如玩漂移或者各种高级的骚操作，那么就需要**手动挡**，也就是 Lock 接口的实现类。

而 synchronized 在经过 Java 每个版本的各种优化后，效率也变得很高了。只是使用起来没有 Lock 接口的实现类那么方便。

### synchronized 锁升级过程就是其优化的核心：**偏向锁** -> **轻量级锁** -> **重量级锁**

```java

class Test{
    private static final Object object = new Object(); 
    
    public void test(){
        synchronized(object) {
            // do something        
        }   
    }
    
}

```

使用 synchronized 关键字锁住某个代码块的时候，一开始锁对象（就是上述代码中的 object）并不是**重量级锁**，而是偏向锁。
偏向锁的字面意思就是"偏向于第一个获取它的线程"的锁。线程执行完同步代码块之后，并**不会主动释放偏向锁**。当第二次到达同步
代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程 ID 在对象头里存储），如果是则正常往下执行。**由于之前没有释放，
这里就不需要重新加锁**，如果从头到尾都是一个线程在使用锁，很明显偏向锁几乎没有额外开销，性能极高。

一旦有第二个线程加入**锁竞争**，偏向锁转换为**轻量级锁**（**自旋锁**）。锁竞争：如果多个线程轮流获取一个锁，但是每次获取的时候
都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程获取锁的时候，发现锁已经被占用，需要等待其释放，则说明发生了锁竞争。

在轻量级锁状态上继续锁竞争，没有抢到锁的线程进行**自旋**操作，即在一个循环中不停判断是否可以获取锁。获取锁的操作，就是通过 CAS 操
作修改对象头里的锁标志位。先**比较**当前锁标志位是否为**释放**状态，如果是，将其设置为**锁定**状态，比较并设置是原子性操作，这个
是 JVM 层面保证的。当前线程就算持有了锁，然后线程将当前锁的持有者信息改为自己。

假如我们获取到锁的线程操作时间很长，比如会进行复杂的计算，数据量很大的网络传输等；那么其它等待锁的线程就会进入长时间的自旋操作，这个
过程是非常耗资源的。其实这时候相当于只有一个线程在有效地工作，其它的线程什么都干不了，在白白地消耗 CPU，这种现象叫做**忙等
（busy-waiting）**。所以如果多个线程使用**独占锁**，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么 synchronized 就是轻量
级锁，允许短时间的忙等现象。这是一种择中的想法，**短时间的忙等，换取线程在用户态和内核态之间切换的开销**。

显然，忙等是有限度的（JVM 有一个计数器记录自旋次数，默认允许循环 10 次，可以通过[虚拟机参数更改](#参数介绍)）。如果锁竞争情况严重，
达到某个最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是通过 CAS 修改锁标志位，但不修改持有锁的线程 ID）。当后续线程尝试获取
锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是上面说的忙等，即不会自旋），等待释放锁的线程去唤醒。在 JDK1.6 之前， synchronized
直接加重量级锁，很明显现在通过一系列的优化过后，性能明显得到了提升。

JVM 中，synchronized 锁只能按照偏向锁、轻量级锁、重量级锁的顺序逐渐升级（也有把这个称为**锁膨胀**的过程），不允许降级。

## 可重入锁（递归锁）

## 公平锁和非公平锁

## 参数介绍

-XX:-UseBiasedLocking=false 关闭偏向锁

```

JDK1.6 

-XX:+UseSpinning 开启自旋锁

-XX:PreBlockSpin=10 设置自旋次数 

JDK1.7 之后 去掉此参数，由 JVM 控制


```





 